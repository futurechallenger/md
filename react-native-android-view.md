# React Fiber 架构

## 简介
React Fiber是一个即将（现在已经是）成为React核心算法的实现。是React团队距离两年多研究的成果。

React Fiber的目的是增加React在动画、布局和手势领域的性能。其中最称道的特性是**增量绘制**：把绘制任务分块，并插入多个帧中。

其他的关键特性包括暂停、放弃和在新的绘制任务发生的时候的重用。以及，指定不同更新的优先级和新的并发处理能力。

## 关于本文
Fiber引入了几个概念，这些概念单凭读代码很难理解。这篇文章开始会介绍Fiber的实现理念。这也趋势对读者有帮助。

我会尽量用大白话来介绍，而不是堆砌一堆的专业术语。我也会在可能的时候引入外部资源。

请注意，我（作者）不在React团队，也不能代表任何的官方意见。**这不是官方的文档。**不过我有邀请React团第的成员Review本文以确保准确。

本文也会持续更新（目前看来并没有）。**Fiber是一个开发中的项目（现在已经完成），并且在完成以前很可能会经历比较大的重构**。所以非常欢迎各位提意见。

## 前提
我假设你们队下面的内容都已经非常熟悉：
* [React组件、元素和实例](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html) - “组件”是一个被使用的太多了，准确理解他们至关重要。
* [一致性算法](https://facebook.github.io/react/docs/reconciliation.html) - 一个高读概括的React一致性算法描述。
* [React基本技术概念](https://github.com/reactjs/react-basic) - 一个React的概念描述，基本不涉及实现细节。有些内容第一次阅读的时候可能没什么意义，时间久了以后就很重要了。
* [React设计理念](https://facebook.github.io/react/contributing/design-principles.html)这一部分需要花时间阅读。这里花了很多内容来解释为什么需要Fiber。

## 复习
在继续往下开始新的内容以前我们先来复习一下上面提到的必看内容。

### 什么事一致性算法
#### 一致性算法
  这是一个React用来比较两个树的不同的算法

#### 更新
  绘制React的数据变化了，通常这是调用`setState`方法的结果。最终会导致一次重绘。

React的核心思想是一次更新会不会导致整个app重绘。这会让开发者更加容易掌控，而不是去担心如何有效的控制app从一个状态变到另一个状态。

事实上每次改动都重绘（re-render）整个app只会出现在一些小的app上。真正的产品级app是极其注重性能的。React有很好的优化，在界面重绘的时候依然可以保持良好的性能。这些性能的优化措施里很重要的一个就是**一致性算法**。

一致性算法就是“虚拟DOM”的底层实现。一个高层次的概括可以描述为：当绘制一个React应用的时候，一个描述app的树和相应的节点就会被保存在内存中。这个树之后会被放在绘制环境中 -- 比如，一个浏览器应用，会被绘制为一些列的HTML Dom。当app被更新的时候（一般是通过调用`setState`方法），一个新的树就会生成出来。新的树会和老的树对比不同来计算那些操作需要更新app。

虽然Fiber一个重新实现的一致性算法，当时总体的思想基本不变。主要包括：

* 不同的组件类型会产生不同的子树。React不会一一比较他们的不同，而是直接替换掉老的树。
* 使用键值来对比列表的不同。这些键必须是“稳定的、可预测的以及唯一的”。

## 一致性算法与绘制
Dom这是React可以执行绘制的环境之一，另一个绘制环境是原生的iOS和Android视图，这是由React Native实现的。（这也是为什么“虚拟DOM”有一点用词不当）。

React可以支持这么多的绘制目标是因为一致性和绘制是分开的两步。一致性用来计算树的那部分发生了变化；绘制的部分用这些信息来事实上更新app。

这一分离才使得React DOM和React Native可以使用各自的绘制器，而可以使用同一个React核心提供的一致性工具。

Fiber重新实现了一致性工具。它不再主要关注于绘制，虽然绘制也发生了对应的改变。

## 计划任务（Scheduling）
#### 计划任务
  用来决定什么时候执行一个任务

####任务（work）
  任何必然发生的计算。任务一般是更新引发的（比如:`setState`）。

React的设计思想一本中有如下的描述非常的贴切：
```
在当前实现中，每一次的更新，React会递归遍历树，并对已经改变的子树上调用重绘绘制方法。但是在未来，它会延迟某些更新以免发生丢帧。

这是React设计中的一般认识。某些流行的库在获得了新数据之后实现了推的操作。然而React则使用了拉的操作，这样某些计算可以延迟到合适的时候执行。

React不是用来处理数据的，它是用来绘制用户界面的。在一个app钟区分哪些计算是相关的哪些不是至关重要。

如果某些东西已经在屏幕外了，我们就可以延迟他们的计算。如果数据产生的比界面绘制的帧数快，我们可以打包处理更新。我们可以给来自用户的交互任务划分优先级（比如一个按钮点击之后的动画）而不是优先处理后台任任务（比如根据网络数据绘制新界面）以免丢帧。
```
**主要的几点是**：
* 在UI中，并不是每一个更新都有必要立刻实现；事实上，这么做非常的浪费，并且会发生丢帧从而减低用户体验。
* 不同的更新有不同的优先级 -- 一个动画的更新需要比来自数据的更新快速的完成
* 一个基于推的app需要开发者来决定什么时候来计划一个任务。一个基于拉的app则更加的灵活，比如React会替你做出决定。

React没有大面积的使用计划任务；一个子树的更新都立刻发生了。能发挥计划任务的优势这个想法也是推动Fiber实现的因素之一。

## Fiber是什么
接下来我们就来讨论React Fiber的核心架构。Fiber是一个低层次的抽象。如果你发现你很难理解这一点，不要气馁，多试几次其义自见。

Fiber的目的之一就是能够发挥计划任务的优势。尤其是我们需要能够做到如下几点：
* 暂停任务，之后回来继续执行
* 给不同类型的任务指定优先级
* 重用之前已经完成的任务
* 不需要的时候放弃任务

为了实现上面的几点，我们首先需要把任务分解成一个个的小单元。在某种意义上，Fiber就是用来做这些的。一个fiber就代表了一个任务的一个单元。

在继续往下以前，我们来回顾一下[React组件作为处理数据的方法](https://github.com/reactjs/react-basic#transformation)，一般表述为：
```
v = f(d)
```
React的绘制就像是一个方法的调用，这个方法又回去调用其他的方法。这个类比对于理解fiber非常有用。

一个计算机程序用来记录程序执行的工具是调用栈（call stack）。当一个方法执行完成后，一个新的栈帧就添加到了调用栈里。每一帧代表了一个方法执行的任务。

当处理UI的时候，太多的任务都放在一起处理的话，就会造成动画的掉帧。更加严重的是，某些任务并没有执行的必要，尤其是那些会被最近执行的更新取代的任务。这也是组件和函数比较不成立的地方，总体来说组件要关心更多的细节。

比较新的浏览器（以及React Native）实现的可以帮助理解这个问题：`requestIdleCallback`会设置一个低优先级的方法在空闲的时候执行。并且`requestAnimationFrame`会设置一个高优先级的方法在下一个动画帧里执行。这个问题是：为了使用这些API，你需要把绘制任务分解成增量的单元。如果你依赖于回调，它会一直执行直到调用栈变空。

